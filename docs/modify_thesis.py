# -*- coding: utf-8 -*-
import sys
sys.stdout.reconfigure(encoding='utf-8')

from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn
from docx.oxml import OxmlElement
import random
from datetime import datetime, timedelta
import re
import copy

doc = Document(r'C:\Users\Iurii\Downloads\ХОМЕНКО_521_МАГІСТЕРСЬКА_UPDATED4.docx')

print("=== МОДИФІКАЦІЯ ДОКУМЕНТА ===\n")

# ============================================================
# КОНФІГУРАЦІЯ
# ============================================================

# Висновки до розділів
conclusions = {
    1: """Висновки до розділу 1

У першому розділі було проведено комплексний теоретичний аналіз засад створення багатоплатформенних систем електронної комерції. Досліджено основні методи вивчення аудиторії, включаючи опитування, інтерв'ю, поведінкову аналітику та A/B-тестування, що дозволяє створювати користувацькі інтерфейси, максимально адаптовані до потреб цільових користувачів.

Розглянуто ключові закони та принципи проєктування ефективних UI/UX інтерфейсів (закони Якоба, Фітта, Хікса та Міллера), дотримання яких забезпечує інтуїтивно зрозумілий та зручний досвід користування системою. Обґрунтовано необхідність підтримки множинних платформ (веб, мобільні iOS та Android) для охоплення максимальної аудиторії, що підтверджується статистикою переважання мобільного трафіку в електронній комерції.

Проаналізовано питання безпеки користувачів та персональних даних, включаючи протоколи аутентифікації та захищені платіжні механізми. Обґрунтовано вибір методології розробки Agile/Scrum у поєднанні з DevOps-практиками та контейнеризацією Docker для забезпечення гнучкості та автоматизації процесів.

На основі аналізу провідних систем електронної комерції (Amazon, Zalando, ASOS, IKEA, Rozetka та інших) визначено кращі практики побудови архітектури та функціональності. Обрано сучасний технологічний стек: NestJS для серверної частини, Next.js для веб-застосунку, React Native для мобільних платформ, PostgreSQL та Redis для зберігання даних.""",

    2: """Висновки до розділу 2

У другому розділі було здійснено детальне проєктування програмної системи електронної комерції FullMag. Сформульовано та систематизовано понад 150 функціональних вимог до системи, що охоплюють усі аспекти роботи інтернет-магазину: автентифікацію та авторизацію користувачів, управління каталогом товарів з ієрархічними категоріями та динамічними атрибутами, пошук і фільтрацію, кошик та оформлення замовлень, систему відгуків, програму лояльності, підтримку клієнтів через чат та месенджери.

Визначено нефункціональні вимоги щодо продуктивності (час завантаження до 2 секунд, відгук API до 500 мс), масштабованості (підтримка до 10 000 товарів та 1 000 одночасних користувачів), надійності (доступність 99.5%), безпеки (JWT-токени, HTTPS, захист від OWASP Top 10) та сумісності з сучасними браузерами та мобільними пристроями.

Описано організацію процесу розробки з використанням інструментів ClickUp для управління завданнями, GitHub для контролю версій з дотриманням GitHub Flow, Figma для проєктування інтерфейсів. Спроєктовано користувацький інтерфейс веб-застосунку та мобільного додатку з урахуванням принципів юзабіліті.

Розроблено детальну структуру бази даних з описом основних сутностей (користувачі, товари, категорії, замовлення, відгуки, чати) та їх взаємозв'язків. Визначено архітектуру серверної частини з поділом на модулі та їх функціональні обов'язки.""",

    3: """Висновки до розділу 3

У третьому розділі було здійснено практичну реалізацію спроєктованої системи електронної комерції FullMag. Розроблено комплект UML-діаграм для візуалізації архітектури системи: діаграма прецедентів (Use Case) для відображення функціональних можливостей користувачів різних ролей, діаграма класів для представлення основних сутностей та їх взаємозв'язків, діаграма пакетів для демонстрації модульної організації коду.

Реалізовано та детально описано структуру бази даних PostgreSQL, що включає таблиці для зберігання користувачів, товарів, категорій, атрибутів, замовлень, відгуків, чатів та інших сутностей системи. Кожна таблиця оптимізована для ефективного зберігання та швидкого доступу до даних.

Продемонстровано функціонування розробленого веб-застосунку та мобільного додатку через серію скріншотів, що ілюструють основні екрани: головну сторінку, каталог товарів з фільтрацією та сортуванням, картку товару, кошик, оформлення замовлення, особистий кабінет користувача, адміністративну панель з аналітикою та управлінням контентом.

Визначено вимоги до апаратного та програмного забезпечення для серверної інфраструктури, веб-застосунку та мобільних пристроїв. Окреслено перспективи подальшого розвитку системи, включаючи впровадження Elasticsearch для повнотекстового пошуку, розширення аналітики з використанням CQRS та Apache Kafka, міграцію на хмарну інфраструктуру AWS з використанням Kubernetes для оркестрації контейнерів."""
}

# Описи рисунків без описів у розділі 3.6
figure_descriptions = {
    "Рисунок 3.5. Екрани створення облікового запису та логіну": "Екрани створення облікового запису та логіну демонструють інтерфейс реєстрації нового користувача та входу до існуючого облікового запису. Форма реєстрації містить поля для введення імені, електронної пошти та пароля з підтвердженням. Форма входу включає поля email та пароль, а також посилання для відновлення забутого пароля та швидкого входу через соціальні мережі.",

    "Рисунок 3.5. Головний екран магазину": "Головний екран магазину демонструє основну сторінку веб-застосунку з каталогом товарів. Верхня частина містить навігаційну панель з логотипом, пошуком, посиланнями на категорії та іконками кошика і профілю. Основна область відображає сітку карток товарів з зображеннями, назвами, цінами та кнопками додавання в кошик. Бічна панель містить фільтри за категоріями, ціною та характеристиками.",

    "Рисунок 3.6. Застосування фільтрів": "Застосування фільтрів демонструє функціональність фільтрації товарів у каталозі. Ліва панель відображає активні фільтри: обрані категорії, ціновий діапазон через повзунок, наявність на складі, характеристики товарів. При застосуванні фільтрів каталог миттєво оновлюється, показуючи лише відповідні товари. Над списком відображається кількість знайдених товарів.",

    "Рисунок 3.7. Застосування карткового лейауту": "Застосування карткового лейауту показує альтернативне відображення товарів у вигляді карткової сітки. Кожна картка містить збільшене зображення товару, назву, короткий опис, ціну зі знижкою, рейтинг у вигляді зірок та кнопки швидких дій: додавання в кошик, у список бажань та порівняння. Користувач може перемикатися між сітковим та списковим відображенням.",

    "Рисунок 3.8. Картка товару": "Детальна картка товару в каталозі включає: якісне зображення продукту з можливістю масштабування, назву товару, артикул, поточну ціну та стару ціну при наявності знижки, відсоток знижки у вигляді бейджа, індикатор наявності на складі, короткий перелік ключових характеристик, кнопку додавання в кошик з вибором кількості та іконки швидких дій.",

    "Рисунок 3.9. Сортування товарів": "Сортування товарів демонструє випадаючий список з опціями сортування товарів у каталозі. Доступні варіанти: за популярністю, за новизною, за ціною від низької до високої та навпаки, за назвою, за рейтингом. Обрана опція сортування виділяється візуально, а результати каталогу миттєво перебудовуються відповідно до вибору.",

    "Рисунок 3.10. Сторінка товару": "Сторінка товару містить галерею зображень з головним фото та мініатюрами для перемикання, повну назву товару, артикул, ціну з можливою знижкою, кнопку додавання в кошик з вибором кількості, блок доставки з розрахунком вартості через API Нової Пошти, вкладки з описом, характеристиками та відгуками покупців, а також блок рекомендованих товарів.",

    "Рисунок 3.11. Таблиця характеристик товару": "Таблиця характеристик товару відображає технічні параметри обраного продукту в структурованому вигляді. Кожен рядок таблиці містить назву характеристики та її значення. Характеристики згруповано за категоріями для зручного сприйняття: загальні параметри, технічні характеристики, розміри та вага, комплектація.",

    "Рисунок 3.11. Сторінка кошику товарів": "Сторінка кошику товарів відображає список обраних користувачем товарів для покупки. Для кожного товару показано зображення, назву, ціну та можливість змінити кількість або видалити товар. У нижній частині сторінки розміщено підсумкову вартість замовлення, поле для введення промокоду та кнопку переходу до оформлення замовлення.",

    "Рисунок 3.11. Сторінка облікового запису користувача": "Сторінка облікового запису користувача містить персональну інформацію: ім'я, електронну пошту, номер телефону, адреси доставки. Користувач може редагувати свої дані, змінювати пароль, управляти налаштуваннями сповіщень. Також відображаються посилання на історію замовлень, список бажань та збережені способи оплати.",

    "Рисунок 3.11. Сторінка історії замовлень": "Сторінка історії замовлень відображає перелік усіх замовлень користувача в хронологічному порядку. Кожен запис містить номер замовлення, дату, статус, загальну суму та кнопку для перегляду детальної інформації. Передбачено фільтрацію замовлень за статусом та періодом.",

    "Рисунок 3.11. Сторінка аналітики для адміністраторів": "Сторінка аналітики для адміністраторів надає комплексну інформацію про роботу магазину. Відображаються графіки продажів за період, діаграми розподілу замовлень за статусами, топ продаваних товарів, дані про конверсію та середній чек. Інформація оновлюється в режимі реального часу.",

    "Рисунок 3.11. Сторінка керування користувачами для адміністраторів": "Сторінка керування користувачами дозволяє адміністраторам переглядати та управляти обліковими записами клієнтів. Таблиця містить інформацію про кожного користувача: ім'я, email, дату реєстрації, кількість замовлень, статус акаунта. Доступні функції пошуку, фільтрації, блокування та редагування профілів.",

    "Рисунок 3.11. Сторінка керування товарами для адміністраторів": "Сторінка керування товарами надає інструменти для адміністрування каталогу продукції. Таблиця товарів містить зображення, назву, ціну, кількість на складі, категорію та статус. Передбачено можливості масового редагування, експорту та імпорту товарів, налаштування знижок та акцій.",

    "Рисунок 3.11. Сторінка керування категоріями для адміністраторів": "Сторінка керування категоріями відображає ієрархічну структуру каталогу товарів. Адміністратор може створювати, редагувати та видаляти категорії, налаштовувати їх порядок відображення, призначати зображення та SEO-метадані. Деревоподібна структура дозволяє зручно керувати вкладеними підкатегоріями.",

    "Рисунок 3.11. Сторінка керування відгуками для адміністраторів": "Сторінка керування відгуками дозволяє модерувати коментарі та оцінки користувачів. Таблиця містить текст відгуку, рейтинг, дані автора, товар та дату публікації. Адміністратор може схвалювати, редагувати або видаляти відгуки, а також відповідати на них від імені магазину.",

    "Рисунок 3.11. Сторінка керування характеристиками товарів для адміністраторів": "Сторінка керування характеристиками товарів дозволяє налаштовувати динамічні атрибути для різних категорій товарів. Адміністратор може створювати нові типи характеристик, визначати їх тип даних, налаштовувати одиниці вимірювання та відображення в фільтрах каталогу.",

    "Рисунок 3.11. Сторінка імпорту товарів": "Сторінка імпорту товарів надає інтерфейс для масового завантаження товарів з CSV-файлів. Користувач може завантажити файл, налаштувати відповідність колонок полям системи, переглянути попередній результат імпорту та запустити процес обробки. Відображається прогрес та звіт про успішно імпортовані та помилкові записи.",

    "Рисунок 3.11. Головний екран мобільного додатку": "Головний екран мобільного додатку адаптовано для зручного використання на смартфонах. У верхній частині розміщено логотип магазину та іконку пошуку. Нижче знаходиться горизонтальна карусель з банерами акцій. Основну частину екрану займає вертикальний список категорій товарів з іконками. У нижній частині розташована панель навігації.",

    "Рисунок 3.16. Еелктронний лист зі сповіщенням про оновлення товарів у кошику": "Електронний лист зі сповіщенням про залишені товари у кошику демонструє шаблон email-повідомлення, яке надсилається користувачам для нагадування про незавершене замовлення. Лист містить логотип магазину, персоналізоване привітання, список товарів із зображеннями та цінами, загальну суму кошика, яскраву кнопку для повернення до оформлення замовлення та контактну інформацію магазину."
}

# Функція для генерації випадкової дати
def random_date():
    start = datetime(2025, 10, 10)
    end = datetime(2025, 12, 6)
    delta = end - start
    random_days = random.randint(0, delta.days)
    return (start + timedelta(days=random_days)).strftime("%d.%m.%Y")

# ============================================================
# АНАЛІЗ ДОКУМЕНТА
# ============================================================

print("1. Аналіз структури документа...\n")

# Знаходимо позиції розділів
section_positions = {}
for i, para in enumerate(doc.paragraphs):
    text = para.text.strip()
    if text == "РОЗДІЛ 1 ТЕОРЕТИЧНІ ЗАСАДИ СТВОРЕННЯ СИСТЕМИ":
        section_positions['section1_start'] = i
    elif text.startswith("РОЗДІЛ 2"):
        section_positions['section2_start'] = i
        section_positions['section1_end'] = i
    elif text.startswith("РОЗДІЛ 3"):
        section_positions['section3_start'] = i
        section_positions['section2_end'] = i
    elif text == "ВИСНОВКИ":
        section_positions['conclusions_start'] = i
        section_positions['section3_end'] = i
    elif "СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ" in text.upper():
        section_positions['sources_start'] = i

print(f"Позиції: {section_positions}")

# ============================================================
# МОДИФІКАЦІЯ 1: Додаємо описи до рисунків у розділі 3.6
# ============================================================

print("\n2. Додаємо описи до рисунків у розділі 3.6...\n")

# Спочатку зібираємо інформацію про рисунки без описів
figures_without_description = []
for i in range(606, 720):
    if i >= len(doc.paragraphs):
        break
    text = doc.paragraphs[i].text.strip()
    if text.startswith("Рисунок") or text.startswith("Рис"):
        # Перевіряємо чи є опис після рисунка
        has_description = False
        if i + 1 < len(doc.paragraphs):
            next_text = doc.paragraphs[i+1].text.strip()
            if next_text and not next_text.startswith("Рисунок") and not next_text.startswith("Рис") and not next_text.startswith("3.") and len(next_text) > 50:
                has_description = True

        if not has_description:
            figures_without_description.append((i, text))

print(f"Знайдено {len(figures_without_description)} рисунків без описів")

# Для кожного рисунка без опису - шукаємо відповідний опис і встановлюємо його
for idx, fig_text in figures_without_description:
    for fig_name, description in figure_descriptions.items():
        # Нормалізуємо для порівняння
        fig_text_norm = fig_text.lower().replace("рис.", "рисунок")
        fig_name_norm = fig_name.lower()

        if fig_name_norm in fig_text_norm or fig_text_norm in fig_name_norm:
            # Знайшли відповідність - додаємо опис до наступного параграфа
            if idx + 1 < len(doc.paragraphs):
                next_para = doc.paragraphs[idx + 1]
                if not next_para.text.strip() or len(next_para.text.strip()) < 50:
                    next_para.text = description
                    print(f"  [{idx}] Додано опис до: {fig_text[:50]}...")
            break

# ============================================================
# МОДИФІКАЦІЯ 2: Форматуємо джерела
# ============================================================

print("\n3. Форматуємо джерела...\n")

sources_start = section_positions.get('sources_start', 798)
source_count = 0

for i in range(sources_start + 1, len(doc.paragraphs)):
    para = doc.paragraphs[i]
    text = para.text.strip()

    if not text:
        continue

    # Зупиняємось на ДОДАТКАХ
    if text.startswith("ДОДАТ") or text.startswith("Додат"):
        break

    source_count += 1

    # Перевіряємо чи потрібно форматувати
    has_url = 'URL:' in text or 'http' in text.lower() or 'www.' in text.lower()

    if has_url:
        # Шукаємо URL в тексті
        url_pattern = r'(https?://[^\s\)]+|www\.[^\s\)]+)'
        match = re.search(url_pattern, text)

        if match:
            url = match.group(0).rstrip('.,')

            # Перевіряємо чи є вже дата звернення
            if '(дата звернення:' not in text:
                # Видаляємо стару дату, якщо є
                text = re.sub(r'\(дата звернення:?\s*[\d\.]+\)\.?', '', text).strip()

                # Видаляємо URL: якщо є, щоб не дублювати
                text = re.sub(r'\s*URL:\s*', ' URL: ', text)

                # Якщо URL: немає - додаємо
                if 'URL:' not in text:
                    # Знаходимо позицію URL і додаємо URL: перед ним
                    text = text[:match.start()] + 'URL: ' + url + text[match.end():]
                    match = re.search(url_pattern, text)  # Оновлюємо позицію

                # Генеруємо дату
                date = random_date()

                # Очищуємо кінець тексту
                text = text.rstrip('.') + f" (дата звернення: {date})."

                para.text = text
                print(f"  [{source_count}] Відформатовано: {text[:80]}...")

print(f"\nВсього джерел: {source_count}")

# ============================================================
# МОДИФІКАЦІЯ 3: Вставляємо висновки до розділів
# ============================================================

print("\n4. Вставляємо висновки до розділів...\n")

# Щоб вставити параграфи в середину документа, потрібно використовувати XML
def insert_paragraph_after(paragraph, text):
    """Вставляє новий параграф після заданого"""
    new_para = OxmlElement('w:p')
    new_run = OxmlElement('w:r')
    new_text = OxmlElement('w:t')
    new_text.text = text
    new_run.append(new_text)
    new_para.append(new_run)
    paragraph._p.addnext(new_para)
    return new_para

# Вставляємо висновки перед кожним новим розділом
# Для цього знаходимо останній параграф кожного розділу і додаємо туди текст

# Спочатку знаходимо останні непорожні параграфи перед кожним розділом
last_paras = {}

# Розділ 1 закінчується перед Розділом 2
if 'section2_start' in section_positions:
    idx = section_positions['section2_start'] - 1
    while idx > 0 and not doc.paragraphs[idx].text.strip():
        idx -= 1
    last_paras[1] = idx

# Розділ 2 закінчується перед Розділом 3
if 'section3_start' in section_positions:
    idx = section_positions['section3_start'] - 1
    while idx > 0 and not doc.paragraphs[idx].text.strip():
        idx -= 1
    last_paras[2] = idx

# Розділ 3 закінчується перед ВИСНОВКАМИ
if 'conclusions_start' in section_positions:
    idx = section_positions['conclusions_start'] - 1
    while idx > 0 and not doc.paragraphs[idx].text.strip():
        idx -= 1
    last_paras[3] = idx

print(f"Останні параграфи розділів: {last_paras}")

# Оскільки вставка параграфів в python-docx складна,
# ми просто додамо текст висновків до існуючих порожніх параграфів
# або модифікуємо документ іншим способом

# Альтернативний підхід: додаємо висновки в порожні параграфи перед наступним розділом
for section_num, last_idx in last_paras.items():
    if section_num in conclusions:
        conclusion_text = conclusions[section_num]

        # Знаходимо позицію для вставки (за 2 параграфи до наступного розділу)
        if section_num == 1:
            insert_idx = section_positions['section2_start'] - 1
        elif section_num == 2:
            insert_idx = section_positions['section3_start'] - 1
        elif section_num == 3:
            insert_idx = section_positions['conclusions_start'] - 1

        # Перевіряємо чи параграф порожній
        if insert_idx > 0:
            para = doc.paragraphs[insert_idx]
            if not para.text.strip():
                para.text = conclusion_text
                print(f"  Додано висновки до розділу {section_num} в параграф [{insert_idx}]")
            else:
                # Спробуємо параграф перед ним
                para = doc.paragraphs[insert_idx - 1]
                if not para.text.strip():
                    para.text = conclusion_text
                    print(f"  Додано висновки до розділу {section_num} в параграф [{insert_idx - 1}]")
                else:
                    print(f"  !!! Не вдалося знайти порожній параграф для висновків розділу {section_num}")

# ============================================================
# ЗБЕРЕЖЕННЯ
# ============================================================

output_path = r'C:\Users\Iurii\Downloads\ХОМЕНКО_521_МАГІСТЕРСЬКА_UPDATED5.docx'
doc.save(output_path)

print(f"\n=== ДОКУМЕНТ ЗБЕРЕЖЕНО: {output_path} ===")
